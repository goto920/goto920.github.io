{"version":3,"sources":["../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/construct.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/isNativeFunction.js","jslibs/MyPitchShifterWorkletNode.js"],"names":["Parent","args","Class","isNativeReflectConstruct","Reflect","construct","a","push","apply","instance","Function","bind","setPrototypeOf","prototype","arguments","_cache","Map","undefined","fn","toString","call","indexOf","TypeError","has","get","set","Wrapper","getPrototypeOf","this","constructor","Object","create","value","enumerable","writable","configurable","noop","MyPitchShifterWorkletNode","context","workletName","options","name","recording","processorOptions","sampleRate","port","onmessage","messageProcessor","_onUpdate","_onEnd","recordedSamples","_recordedBuffer","running","func","postMessage","command","tempo","pitch","console","log","disconnect","e","data","stop","status","filename","audioBuffer","output","_recordBuffer","blob","Blob","toWav","type","saveAs","length","createBuffer","left","getChannelData","right","AudioWorkletNode"],"mappings":"wNAEe,SAAS,EAAWA,EAAQC,EAAMC,GAc/C,OAZE,EADE,OAAAC,EAAA,KACWC,QAAQC,UAER,SAAoBL,EAAQC,EAAMC,GAC7C,IAAII,EAAI,CAAC,MACTA,EAAEC,KAAKC,MAAMF,EAAGL,GAChB,IACIQ,EAAW,IADGC,SAASC,KAAKH,MAAMR,EAAQM,IAG9C,OADIJ,GAAO,OAAAU,EAAA,GAAeH,EAAUP,EAAMW,WACnCJ,IAIOD,MAAM,KAAMM,WCZjB,SAAS,EAAiBZ,GACvC,IAAIa,EAAwB,oBAARC,IAAqB,IAAIA,SAAQC,EA8BrD,OA5BA,EAAmB,SAA0Bf,GAC3C,GAAc,OAAVA,ICRkCgB,EDQEhB,GCPsB,IAAzDQ,SAASS,SAASC,KAAKF,GAAIG,QAAQ,kBDOQ,OAAOnB,ECR5C,IAA2BgB,EDUtC,GAAqB,oBAAVhB,EACT,MAAM,IAAIoB,UAAU,sDAGtB,GAAsB,qBAAXP,EAAwB,CACjC,GAAIA,EAAOQ,IAAIrB,GAAQ,OAAOa,EAAOS,IAAItB,GAEzCa,EAAOU,IAAIvB,EAAOwB,GAGpB,SAASA,IACP,OAAO,EAAUxB,EAAOY,UAAW,OAAAa,EAAA,GAAeC,MAAMC,aAW1D,OARAH,EAAQb,UAAYiB,OAAOC,OAAO7B,EAAMW,UAAW,CACjDgB,YAAa,CACXG,MAAON,EACPO,YAAY,EACZC,UAAU,EACVC,cAAc,KAGX,OAAAvB,EAAA,GAAec,EAASxB,KAGTA,G,oBEhCpBkC,EAAO,aAGPC,E,kDACJ,WAAYC,EAAQC,EAAaC,GAAS,IAAD,8BACvC,cAAMF,EAASC,EAAaC,IAEvBC,KAAO,EAAKZ,YAAYY,KAG7B,EAAKC,UAAYF,EAAQG,iBAAiBD,UAC1C,EAAKE,WAAaJ,EAAQG,iBAAiBC,WAC3C,EAAKC,KAAKC,UAAY,EAAKC,iBAAiBpC,KAAtB,gBACtB,EAAKqC,UAAYZ,EACjB,EAAKa,OAASb,EACd,EAAKc,gBAAkB,KACvB,EAAKC,gBAAkB,KAEvB,EAAKC,SAAU,EAdwB,E,sCAkB3C,WAAY,OAAOxB,O,iBAEjB,SAAWyB,GAAQzB,KAAKqB,OAASI,I,oBACjC,SAAcA,GAAQzB,KAAKoB,UAAYK,I,4BAEvC,SAAsBrB,GACpBJ,KAAKiB,KAAKS,YAAY,CAACC,QAAS,mBAAoBtD,KAAM,CAAC+B,O,iBAK7D,WAEE,OADAJ,KAAKiB,KAAKS,YAAY,CAACC,QAAS,WAAYtD,KAAM,KAC3C2B,KAAK4B,O,IANd,SAAUxB,GACRJ,KAAKiB,KAAKS,YAAY,CAACC,QAAS,WAAYtD,KAAM,CAAC+B,O,iBAOrD,WAEE,OADAJ,KAAKiB,KAAKS,YAAY,CAACC,QAAS,WAAYtD,KAAM,KAC3C2B,KAAK6B,O,IARd,SAAUzB,GACRJ,KAAKiB,KAAKS,YAAY,CAACC,QAAS,WAAYtD,KAAM,CAAC+B,O,0BAUrD,WACE,OAAOJ,KAAKuB,kB,yDAGd,sBAAA7C,EAAA,yDACOsB,KAAKwB,QADZ,wDAGEM,QAAQC,IAAI/B,KAAKa,KAAM,WAHzB,SAIQb,KAAKiB,KAAKS,YAAY,CAACC,QAAS,OAAQtD,KAAM,KAJtD,OAME2B,KAAKgC,aAOLhC,KAAKqB,OAAOrB,KAAKuB,iBAEjBvB,KAAKwB,SAAU,EAfjB,gD,oFAkBA,SAAiBS,GACf,GAAGA,EAAEC,KAAKP,QAAV,CAAmB,IAAD,EACOM,EAAEC,KAAlBP,EADS,EACTA,QAAQtD,EADC,EACDA,KAEf,OAAOsD,GACL,IAAK,MAWH3B,KAAKmC,OACP,MACA,IAAK,SACHnC,KAAKoB,UAAU/C,EAAK,UAQ1B,GAAI4D,EAAEC,KAAKE,OAAX,CACE,IAAMhC,EAAQ6B,EAAEC,KAAK7D,KAAK,GAC1B,OAAO4D,EAAEC,KAAK7D,KAAK,IACjB,IAAK,WAAY2B,KAAK4B,MAAQxB,EAAO,MACrC,IAAK,WAAYJ,KAAK6B,MAAQzB,W,0BAOpC,SAAciC,GAA8B,IAApBC,EAAmB,uDAAL,KAEhCC,EAAS,KACb,GAAoB,OAAhBD,EAAsBC,EAASD,MAC9B,IAA6B,OAAzBtC,KAAKuB,gBAEoC,YAA5CO,QAAQC,IAAK,8BADjBQ,EAASvC,KAAKwC,cAGhB,IAAMC,EAAO,IAAIC,KAAK,CAACC,EAAMJ,IAAU,CAACK,KAAM,kBAC9CC,iBAAOJ,EAAMJ,K,kCAKf,WACE,GAAKrC,KAAKsB,gBAAV,CAKA,GAAuC,IAAnCtB,KAAKsB,gBAAgB,GAAGwB,OAAc,OAAO,KAEjD9C,KAAKuB,gBAAkBvB,KAAKU,QAAQqC,aAClC/C,KAAKsB,gBAAgBwB,OACrB9C,KAAKsB,gBAAgB,GAAGwB,OACxB9C,KAAKgB,YAGP,IAAMgC,EAAOhD,KAAKuB,gBAAgB0B,eAAe,GAC3CC,EAAQlD,KAAKuB,gBAAgB0B,eAAe,GAKlD,OAJAD,EAAKnD,IAAIG,KAAKsB,gBAAgB,IAC9B4B,EAAMrD,IAAIG,KAAKsB,gBAAgB,IAE/BQ,QAAQC,IAAI/B,KAAKa,KAAK,6BACfb,KAAKuB,gBAlBVO,QAAQC,IAAK/B,KAAKa,KAAK,iC,KAnHWsC,mBA2IzB1C","file":"static/js/3.e6e2ee08.chunk.js","sourcesContent":["import setPrototypeOf from \"@babel/runtime/helpers/esm/setPrototypeOf\";\nimport isNativeReflectConstruct from \"@babel/runtime/helpers/esm/isNativeReflectConstruct\";\nexport default function _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}","import getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport setPrototypeOf from \"@babel/runtime/helpers/esm/setPrototypeOf\";\nimport isNativeFunction from \"@babel/runtime/helpers/esm/isNativeFunction\";\nimport construct from \"@babel/runtime/helpers/esm/construct\";\nexport default function _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}","export default function _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}","import {saveAs} from 'file-saver';\nimport * as toWav from 'audiobuffer-to-wav';\n\nconst noop = function() {return;}\n// const sleep = msec => new Promise(resolve => setTimeout(resolve, msec));\n\nclass MyPitchShifterWorkletNode extends AudioWorkletNode {\n  constructor(context,workletName, options){\n    super(context, workletName, options);\n\n    this.name = this.constructor.name;\n\n    // this.context = context; // already in super class\n    this.recording = options.processorOptions.recording;\n    this.sampleRate = options.processorOptions.sampleRate;\n    this.port.onmessage = this.messageProcessor.bind(this);\n    this._onUpdate = noop;\n    this._onEnd = noop;\n    this.recordedSamples = null;\n    this._recordedBuffer = null;\n   \n    this.running = true;\n\n  } // End constructor()\n\nget node(){ return this;} // for compatibility\n\n  set onEnd (func) { this._onEnd = func; }\n  set onUpdate (func) { this._onUpdate = func;}\n\n  set onUpdateInterval (value) { \n    this.port.postMessage({command: 'onUpdateInterval', args: [value]});}\n  set tempo(value){\n    this.port.postMessage({command: 'setTempo', args: [value]}); }\n  set pitch(value){\n    this.port.postMessage({command: 'setPitch', args: [value]}); }\n  get tempo(){\n    this.port.postMessage({command: 'getTempo', args: []}); \n    return this.tempo;\n  }\n  get pitch(){\n    this.port.postMessage({command: 'getPitch', args: []}); \n    return this.pitch;\n  }\n\n  get recordedBuffer(){\n    return this._recordedBuffer;\n  }\n\n  async stop(){\n    if (!this.running) return;\n\n    console.log(this.name, '.stop()');\n    await this.port.postMessage({command: 'stop', args: []});\n\n    this.disconnect();\n/*\n    // await this._recordedBuffer is filled\n    console.log(this.name,'sleep begin');\n    await sleep(3000); // sleep in msec\n    console.log(this.name,'sleep end');\n*/\n    this._onEnd(this._recordedBuffer);\n\n    this.running = false;\n  }\n\n  messageProcessor(e){\n    if(e.data.command){\n      const {command,args} = e.data;\n      // console.log(this.name, 'recvd', command);\n      switch(command) {\n        case 'End':\n          // console.log(this.name, 'recvd', command);\n        /*\n          this.recordedSamples = args[0]; \n          if (this.recordedSamples)\n             console.log (this.name, 'worklet stopped. recordedSamples');\n          else\n             console.log (this.name, 'worklet stopped. NO recordedSamples');\n          if (this.recording) this.createRecordedBuffer();\n        */\n\n          this.stop();\n        break;\n        case 'update' : \n          this._onUpdate(args[0]); // this.playingAt = args[0];\n        break;\n\n        default:\n      }\n      return;\n    }\n\n    if (e.data.status){\n      const value = e.data.args[1];\n      switch(e.data.args[0]){\n        case 'getTempo': this.tempo = value; break;\n        case 'getPitch': this.pitch = value; break;\n        default:\n      }\n      return;\n    }\n  } // End messgeProcessor()\n\n  exportToFile (filename, audioBuffer = null){\n\n    let output = null;\n    if (audioBuffer !== null) output = audioBuffer;\n    else if (this._recordedBuffer !== null)\n      output = this._recordBuffer; // use internal record\n    else {console.log ('output AudioBuffer is null'); return; }\n\n    const blob = new Blob([toWav(output)], {type: 'audio/vnd.wav'});\n    saveAs(blob, filename);\n\n    return;\n  } // end exportToFile()\n\n  createRecordedBuffer() {\n    if (!this.recordedSamples) {\n      console.log (this.name,'this.recordedBuffer empty') \n      return;\n    }\n\n    if (this.recordedSamples[0].length === 0) return null;\n\n    this._recordedBuffer = this.context.createBuffer(\n      this.recordedSamples.length, // channels\n      this.recordedSamples[0].length, // sample length\n      this.sampleRate\n    );\n\n    const left = this._recordedBuffer.getChannelData(0);\n    const right = this._recordedBuffer.getChannelData(1);\n    left.set(this.recordedSamples[0]);\n    right.set(this.recordedSamples[1]);\n\n    console.log(this.name,'createRecordedBuffer done');\n    return this._recordedBuffer;\n\n  } // End createRecordedBuffer\n\n};\n\nexport default MyPitchShifterWorkletNode;\n\n"],"sourceRoot":""}